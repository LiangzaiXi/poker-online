<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ƒê·ªäT M·∫∏ M√ÄY - Balanced Hitbox</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@900&display=swap');

        body {
            background-color: #111;
            color: white;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            /* Crosshair cursor */
            cursor: crosshair; 
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Layer */
        .ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .title-text {
            font-family: 'Black Ops One', cursive;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #ff0000;
        }

        .btn {
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .btn:active {
            transform: scale(0.95);
        }

        /* Rage Mode Filter */
        .rage-mode {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite;
            filter: sepia(1) hue-rotate(-50deg) saturate(5);
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
        /* Aim Cursor */
        .cursor-dot {
            width: 30px; 
            height: 30px;
            border: 3px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s;
        }
        .cursor-dot::after {
            content: '';
            width: 6px;
            height: 6px;
            background: red;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
    </style>
</head>
<body>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Custom Cursor DOM Element -->
    <div id="aim-cursor" class="cursor-dot hidden md:block"></div>

    <!-- START SCREEN -->
    <div id="start-screen" class="ui-layer bg-black/80 backdrop-blur-sm">
        <h1 class="text-6xl md:text-8xl text-red-500 mb-2 title-text text-center leading-tight">
            ƒê·ªäT M·∫∏<br><span class="text-white">M√ÄY</span>
        </h1>
        <p class="mb-8 text-yellow-400 font-bold animate-pulse uppercase">Tap to Smack!</p>
        
        <button id="start-btn" class="btn bg-red-600 hover:bg-red-700 text-white font-black py-4 px-12 rounded-full text-2xl border-4 border-red-800 shadow-[0_0_20px_rgba(255,0,0,0.5)]">
            B·∫ÆT ƒê·∫¶U
        </button>
        <p class="mt-4 text-xs text-gray-500">üîä Sound On (Recomended)</p>
    </div>

    <!-- HUD -->
    <div id="game-ui" class="ui-layer hidden !justify-between p-4 pointer-events-none">
        <div class="w-full flex justify-between items-start">
            <div class="text-left">
                <p class="text-red-500 font-bold text-sm">RAGE</p>
                <div class="w-48 h-6 bg-gray-800 border-2 border-gray-600 rounded skew-x-12 overflow-hidden">
                    <div id="rage-bar" class="h-full bg-gradient-to-r from-yellow-500 to-red-600 w-0 transition-all duration-200"></div>
                </div>
            </div>
            <div class="text-right">
                <p class="text-6xl font-black text-white drop-shadow-lg" id="score">0</p>
                <p class="text-sm text-gray-400">KILLS</p>
            </div>
        </div>
        <div id="combo-text" class="text-4xl md:text-6xl font-black text-yellow-400 opacity-0 transition-opacity duration-100 italic" style="text-shadow: 2px 2px 0 #f00;">
            COMBO x<span id="combo-count">0</span>
        </div>
        <div class="w-full text-center pb-4">
            <p id="timer" class="text-3xl font-mono text-red-500">60</p>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen" class="ui-layer hidden bg-black/90">
        <h2 class="text-5xl text-red-600 font-black mb-4 title-text">H·∫æT GI·ªú!</h2>
        <div class="text-center mb-8">
            <p class="text-2xl text-white">SCORE: <span id="final-score" class="text-yellow-400">0</span></p>
            <p class="text-xl text-gray-400 mt-2">RANK: <span id="rank-text" class="italic text-white font-bold"></span></p>
        </div>
        <button id="restart-btn" class="btn bg-white text-black font-black py-3 px-10 rounded text-xl hover:scale-105 uppercase">
            CH∆†I L·∫†I
        </button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startScreen = document.getElementById('start-screen');
        const gameUI = document.getElementById('game-ui');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const scoreEl = document.getElementById('score');
        const rageBar = document.getElementById('rage-bar');
        const timerEl = document.getElementById('timer');
        const comboText = document.getElementById('combo-text');
        const comboCountEl = document.getElementById('combo-count');
        const aimCursor = document.getElementById('aim-cursor');

        // Game State
        let isPlaying = false;
        let score = 0;
        let timeLeft = 60;
        let rage = 0; 
        let isRageMode = false;
        let mouseX = 0;
        let mouseY = 0;
        let combo = 0;
        let comboTimer = null;

        // Sound Audio Context
        let audioCtx;

        // Assets
        const enemies = [];
        const particles = [];
        const floatTexts = [];
        const slaps = []; 
        
        const enemyEmojis = ['ü§¨', 'ü§°', 'üë∫', 'üñï', 'üòè', 'ü§™', 'üòà'];
        
        // --- VIETNAMESE SWEAR WORDS ---
        const hitWords = [
            'ƒê·ªäT M·∫∏!',      
            'NGU V√ÉI!',     
            'C√öT ƒêI!',      
            'CH√ì ƒê·∫∫!',      
            'V√ÉI L·ªíN!',     
            'M·∫∏ KI·∫æP!',     
            'KH·ªêN N·∫†N!',    
            '√ìC CH√ì!',      
            'TH·∫∞NG ƒêI√äN!',  
            'BI·∫æN!',        
            'ƒê·ªí NGU!',      
            'CH·∫æT ƒêI!',     
            'ƒê√âO!',         
            'ƒÇN C·ª®T!',      
            'M·∫∂T L·ªíN!',     
            'TH·∫∞NG CH√ì!'    
        ];
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Mouse Tracker
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            aimCursor.style.left = mouseX + 'px';
            aimCursor.style.top = mouseY + 'px';
        });

        // --- Sound Manager (Web Audio API) ---
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Generate Smack Sound
        function playSmackSound() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            
            // Impact Noise
            const bufferSize = audioCtx.sampleRate * 0.1; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.value = 1000;

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(1, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start(t);

            // Punchy Body
            const osc = audioCtx.createOscillator();
            osc.type = 'triangle';
            const baseFreq = 150 + Math.random() * 50; 
            osc.frequency.setValueAtTime(baseFreq, t);
            osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);

            const oscGain = audioCtx.createGain();
            oscGain.gain.setValueAtTime(0.8, t);
            oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

            osc.connect(oscGain);
            oscGain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.2);
        }

        // Generate Swoosh/Miss Sound
        function playSwooshSound() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;

            const bufferSize = audioCtx.sampleRate * 0.2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(600, t);
            filter.frequency.linearRampToValueAtTime(1200, t + 0.1);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.linearRampToValueAtTime(0.01, t + 0.15);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start(t);
        }

        // Slipper Animation Class
        class SlipperHit {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.age = 0;
                this.maxAge = 12; // Slow animation
                this.emoji = 'ü©¥';
                this.startAngle = -Math.PI / 2;
                this.endAngle = 0;
            }

            update() {
                this.age++;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                let currentAngle;
                let scale = 1;
                let alpha = 1;

                if (this.age < 4) {
                    const swingProgress = this.age / 4;
                    currentAngle = this.startAngle + (this.endAngle - this.startAngle) * swingProgress;
                    scale = 1.3; 
                } else {
                    currentAngle = this.endAngle;
                    scale = 1.0;
                    alpha = 1 - ((this.age - 4) / (this.maxAge - 4));
                }

                ctx.rotate(currentAngle);
                ctx.scale(scale, scale);
                ctx.globalAlpha = alpha;
                
                ctx.font = "100px Arial"; // Large slipper
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.fillText(this.emoji, 5, 5);
                ctx.fillStyle = "white"; 
                ctx.fillText(this.emoji, 0, 0);
                
                ctx.restore();
            }
        }

        // Click / Slap Handler
        function slap(e) {
            if (!isPlaying) return;
            initAudio(); 
            
            let x, y;
            if(e.type.includes('touch')) {
                x = e.changedTouches[0].clientX;
                y = e.changedTouches[0].clientY;
                aimCursor.style.left = x + 'px';
                aimCursor.style.top = y + 'px';
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            slaps.push(new SlipperHit(x, y));
            
            let hitCount = 0;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = x - enemy.x;
                const dy = y - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // --- BALANCED HITBOX ---
                // Âà§ÂÆöÔºöË°®ÊÉÖÂåÖÂ∞∫ÂØ∏ + 15ÂÉèÁ¥†
                // ËøôÂÖÅËÆ∏Á®çÂæÆÂÅè‰∏ÄÁÇπÁÇπ‰πüËÉΩÊâì‰∏≠ÔºåÊâãÊÑü‰ºöÊØîËæÉÂ•Ω
                if (dist < enemy.size + 15) { 
                    killEnemy(enemy, i);
                    hitCount++;
                }
            }

            if (hitCount === 0) {
                // MISS
                playSwooshSound();
                spawnFloatText(x, y, "H·ª§T!", '#888', 20); 
                combo = 0;
                updateComboUI();
                aimCursor.style.transform = "translate(-50%, -50%) scale(0.8)";
                setTimeout(() => aimCursor.style.transform = "translate(-50%, -50%) scale(1)", 100);
            } else {
                // HIT
                shakeScreen(5 * hitCount); 
                aimCursor.style.transform = "translate(-50%, -50%) scale(1.5)";
                setTimeout(() => aimCursor.style.transform = "translate(-50%, -50%) scale(1)", 100);
            }
        }

        document.addEventListener('mousedown', slap);
        document.addEventListener('touchstart', slap);

        class Enemy {
            constructor() {
                this.size = Math.random() * 30 + 50; 
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = canvas.height + 50; 
                this.emoji = enemyEmojis[Math.floor(Math.random() * enemyEmojis.length)];
                
                this.vx = (Math.random() - 0.5) * 3; 
                this.vy = -(Math.random() * 4 + 10); 
                this.gravity = 0.18; 
                this.rotation = 0;
                this.rotSpeed = (Math.random() - 0.5) * 0.1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.rotation += this.rotSpeed;

                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 15;
                this.vy = (Math.random() - 0.5) * 15;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 5 + 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
                this.vx *= 0.9;
                this.vy *= 0.9;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class FloatingText {
            constructor(x, y, text, color, size) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size || 40;
                this.life = 1.0;
                this.vy = -2;
            }
            update() {
                this.y += this.vy;
                this.life -= 0.02;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.font = `900 ${this.size}px 'Black Ops One', sans-serif`;
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        function killEnemy(enemy, index) {
            enemies.splice(index, 1);
            score++;
            scoreEl.innerText = score;
            
            // PLAY SOUND
            playSmackSound();

            // Rage accumulation
            rage = Math.min(100, rage + 8); 
            updateRage();

            // Combo System
            combo++;
            clearTimeout(comboTimer);
            comboTimer = setTimeout(() => { combo = 0; updateComboUI(); }, 2000);
            updateComboUI();

            const hitWord = hitWords[Math.floor(Math.random() * hitWords.length)];
            spawnFloatText(enemy.x, enemy.y, hitWord, isRageMode ? '#ff0000' : '#ffff00');
            
            for(let i=0; i<8; i++) {
                particles.push(new Particle(enemy.x, enemy.y, '#ff0000'));
                particles.push(new Particle(enemy.x, enemy.y, '#ffff00'));
            }

            shakeScreen(isRageMode ? 20 : 10);
        }

        function spawnFloatText(x, y, text, color, size) {
            floatTexts.push(new FloatingText(x, y, text, color, size));
        }

        function updateRage() {
            rageBar.style.width = `${rage}%`;
            if (rage >= 100 && !isRageMode) {
                enterRageMode();
            }
        }

        function enterRageMode() {
            isRageMode = true;
            document.body.classList.add('rage-mode');
            spawnFloatText(window.innerWidth/2, window.innerHeight/2, "ƒê·ªäT M·∫∏ M√ÄY!!!", "red", 80);
            
            setTimeout(() => {
                isRageMode = false;
                rage = 0;
                updateRage();
                document.body.classList.remove('rage-mode');
            }, 5000);
        }

        function updateComboUI() {
            if (combo > 1) {
                comboCountEl.innerText = combo;
                comboText.style.opacity = 1;
                comboText.style.transform = `scale(${1 + combo * 0.1})`;
            } else {
                comboText.style.opacity = 0;
                comboText.style.transform = 'scale(1)';
            }
        }

        let shakeMagnitude = 0;
        function shakeScreen(amount) {
            shakeMagnitude = amount;
        }

        function spawnLogic() {
            // EASY MODE SPAWN RATES
            let spawnRate = 0.015 + (score * 0.0002); 
            
            if(isRageMode) spawnRate = 0.06; 
            
            if (Math.random() < spawnRate) {
                enemies.push(new Enemy());
            }
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            if (shakeMagnitude > 0) {
                const dx = (Math.random() - 0.5) * shakeMagnitude;
                const dy = (Math.random() - 0.5) * shakeMagnitude;
                ctx.translate(dx, dy);
                shakeMagnitude *= 0.9;
                if(shakeMagnitude < 0.5) shakeMagnitude = 0;
            }

            if (isPlaying) {
                spawnLogic();

                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update();
                    enemies[i].draw();
                    if (enemies[i].y > canvas.height + 100) {
                        enemies.splice(i, 1);
                        combo = 0;
                        updateComboUI();
                    }
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            for (let i = floatTexts.length - 1; i >= 0; i--) {
                floatTexts[i].update();
                floatTexts[i].draw();
                if (floatTexts[i].life <= 0) floatTexts.splice(i, 1);
            }

            for (let i = slaps.length - 1; i >= 0; i--) {
                slaps[i].update();
                slaps[i].draw();
                if (slaps[i].age >= slaps[i].maxAge) {
                    slaps.splice(i, 1);
                }
            }

            ctx.restore(); 

            requestAnimationFrame(loop);
        }

        function startGame() {
            initAudio(); // Initialize Audio Context on user gesture
            isPlaying = true;
            score = 0;
            rage = 0;
            timeLeft = 60;
            enemies.length = 0;
            particles.length = 0;
            floatTexts.length = 0;
            slaps.length = 0;
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            gameUI.classList.add('flex');
            scoreEl.innerText = "0";
            rageBar.style.width = "0%";
            aimCursor.classList.remove('hidden');

            const timerInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameOver();
                }
            }, 1000);
            
            window.gameTimer = timerInterval;
        }

        function gameOver() {
            isPlaying = false;
            clearInterval(window.gameTimer);
            gameUI.classList.add('hidden');
            gameUI.classList.remove('flex');
            gameOverScreen.classList.remove('hidden');
            
            document.getElementById('final-score').innerText = score;
            
            const rankEl = document.getElementById('rank-text');
            // LOCALIZED RANKS
            if (score < 20) rankEl.innerText = "QU√Å Y·∫æU!";
            else if (score < 50) rankEl.innerText = "T·∫†M ƒê∆Ø·ª¢C";
            else if (score < 100) rankEl.innerText = "R·∫§T CAY C√ö!";
            else rankEl.innerText = "TH√ÅNH CH·ª¨I!";
        }

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);

        loop();

    </script>
</body>
</html>
